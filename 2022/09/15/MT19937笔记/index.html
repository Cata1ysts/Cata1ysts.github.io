<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简简单单地记录一下梅森旋转算法中MT19937及其攻击">
<meta property="og:type" content="article">
<meta property="og:title" content="MT19937笔记">
<meta property="og:url" content="http://example.com/2022/09/15/MT19937%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Cata1yst&#39;s blog">
<meta property="og:description" content="简简单单地记录一下梅森旋转算法中MT19937及其攻击">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-15T10:55:36.000Z">
<meta property="article:modified_time" content="2022-09-25T07:12:50.492Z">
<meta property="article:author" content="Cata1ysts">
<meta property="article:tag" content="PRNG">
<meta property="article:tag" content="Mersenne twister">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/09/15/MT19937%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MT19937笔记 | Cata1yst's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cata1yst's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">祇今尚有清流月，曾照高王万马过</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/15/MT19937%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cata1ysts">
      <meta itemprop="description" content="努力学习crypto并希望有一个web大手子浇浇的pwn萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cata1yst's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MT19937笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-15 18:55:36" itemprop="dateCreated datePublished" datetime="2022-09-15T18:55:36+08:00">2022-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 15:12:50" itemprop="dateModified" datetime="2022-09-25T15:12:50+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/Crypto/" itemprop="url" rel="index"><span itemprop="name">Crypto</span></a>
                </span>
            </span>

          
            <div class="post-description">简简单单地记录一下梅森旋转算法中MT19937及其攻击</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

<h3 id="Mersenne-twister-算法介绍"><a href="#Mersenne-twister-算法介绍" class="headerlink" title="Mersenne twister 算法介绍"></a>Mersenne twister 算法介绍</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>$Mersenne\ twister$ 算法是一种周期非常长的伪随机数算法，它和传统的 $LFSR$ 算法有一些相似之处，因而在泄露足够多的伪随机数后也很容易受到攻击。该算法的主体分为初始序列生成、旋转、输出三步。</p>
<h4 id="初始序列生成"><a href="#初始序列生成" class="headerlink" title="初始序列生成"></a>初始序列生成</h4><p>和 $LFSR$ 一样，我们需要初始化一个序列 $state$ ，这个序列的长度直接关系到生成器的周期。与之不同的是，这里我们只需要一个初始种子 $seed$ 和一个固定算法 $F_1$。</p>
<p>在 $MT19937$ 中，该算法被描述成如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#n 序列长度，一般取624</span></span><br><span class="line"><span class="comment">#a 随机乘量，一般取1812433253</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_state</span>(<span class="params">seed</span>):</span><br><span class="line">    state=[seed]+[<span class="number">0</span>]*(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        state[i] = a * (state[i-<span class="number">1</span>] ^ (state[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>)) + i</span><br><span class="line">        state[i] &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这个算法，我们可以得到 $n$ 个32比特的数。</p>
<p>当然了，我们也可以人为地修改里面的参数来达到某些特定目的。</p>
<h4 id="旋转算法"><a href="#旋转算法" class="headerlink" title="旋转算法"></a>旋转算法</h4><p>梅森旋转算法能够构造大周期伪随机数生成器的原因就在这里，不过此处并不想分析缘由<del>（其实是自己也看不懂</del>仍然只是给出代码形式。这一步类似于 $LFSR$ 中由前 $x$ 比特生成下一比特的过程，只不过这里的“比特”不是 0 或 1 ，而是一个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#highbit 0x80000000</span></span><br><span class="line"><span class="comment">#lowbit 0x7fffffff</span></span><br><span class="line"><span class="comment">#mask 掩码，一般为0x9908b0df</span></span><br><span class="line"><span class="comment">#o 一个[0,n]的整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        y = (state[i] &amp; highbit) | (state[(i + <span class="number">1</span>) % n] &amp; lowbit)</span><br><span class="line">        state[i] = (y&gt;&gt;<span class="number">1</span>) ^ state[(i + o) % n]</span><br><span class="line">		<span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            state[i] = state[i] ^ mask</span><br></pre></td></tr></table></figure>

<p>稍微解释一下这一步的操作。首先是 $state[i]$ 的最高位以及 $state[i+1]$ 的低31位合并为一个新的数 $y$ ，根据 $y$ 的奇偶性得到两种操作，若 $y$ 是偶数，则 $state[i]&#x3D;(y&gt;&gt;1)\bigoplus state[i+o]$ 否则 $state[i]&#x3D;(y&gt;&gt;1)\bigoplus state[i+o] \bigoplus mask$ 。</p>
<p>通过矩阵<strong>（以下默认所有矩阵是在GF(2)上进行的）</strong>，我们可以使得格式更加统一<br>$$<br>y&#x3D;(state_i\ \bigwedge\ highbit) + (state_{i + 1}\ \bigwedge\ lowbit)<br>$$</p>
<p>$$<br>Y&#x3D;[y_{31},y_{30}…,y_0] ,\ y_i&#x3D;{0,1}\ \ y二进制数组成的向量<br>$$</p>
<p>$$<br>STATE_i\ \ state_i的二进制数向量<br>$$</p>
<p>$$<br>mask&#x3D;[a_{31},a_{30}…,a_0] ,\ a_i&#x3D;{0,1} \ \ mask二进制数组成的向量<br>$$</p>
<p>$$<br>Y&#x3D;YA<br>$$</p>
<p>$$<br>STATE_i&#x3D;Y+STATE_{i+o}<br>$$</p>
<p>其中<br>$$<br>A&#x3D;\left[<br> \begin{matrix}<br>   0 &amp; 1 &amp; 0 &amp; \cdots&amp; 0\\<br>   0 &amp; 0 &amp; 1 &amp;\cdots &amp; 0\\<br>   \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\<br>   a_{31} &amp; a_{30} &amp; a_{29} &amp; \cdots &amp; a_0\\<br>  \end{matrix}<br>  \right]\\<br>$$<br>可以看出，两种模式得到的结果是一样的。</p>
<p>这个算法相对固定，在很多 $MT19937$ 的变体中这一步是不变的。</p>
<h4 id="输出算法"><a href="#输出算法" class="headerlink" title="输出算法"></a>输出算法</h4><p>这很有趣，因为 $LFSR$ 中是直接输出原来序列的最低位的。那我们来看看具体操作吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#b = 0x9d2c5680</span></span><br><span class="line"><span class="comment">#c = 0xefc60000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">state,i</span>):</span><br><span class="line">    x = state[i]</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">11</span></span><br><span class="line">    x ^= (x &lt;&lt; <span class="number">7</span>) &amp; b</span><br><span class="line">    x ^= (x &lt;&lt; <span class="number">15</span>) &amp; c</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">18</span></span><br><span class="line">    <span class="keyword">if</span> i==n-<span class="number">1</span>:</span><br><span class="line">        twist(state)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>这个也很简单，看得出来，输出结果是 $state[i]$ 映射，因此当我们遍历完一组 $state$ 后，需要再次旋转获得一组新的 $state$ 。</p>
<p>另外的话，许多变体喜欢在这里修修改改，不过主体就是这样一个过程。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>下面我们通过定义一个 $MT19937$ 类来结束这一部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        self.n = <span class="number">624</span></span><br><span class="line">        self.o = <span class="number">397</span></span><br><span class="line">        self.a = <span class="number">0x6c078965</span></span><br><span class="line">        self.b = <span class="number">0x9d2c5680</span></span><br><span class="line">        self.c = <span class="number">0xefc60000</span></span><br><span class="line">        self.highbit = <span class="number">0x80000000</span></span><br><span class="line">        self.lowbit = <span class="number">0x7fffffff</span></span><br><span class="line">        self.mask = <span class="number">0x9908b0df</span></span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.state=[seed]+[<span class="number">0</span>]*(self.n-<span class="number">1</span>)</span><br><span class="line">        self.gen_state()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_state</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,self.n):</span><br><span class="line">            self.state[i] = self.a * (self.state[i-<span class="number">1</span>] ^ (self.state[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>)) + i</span><br><span class="line">            self.state[i] &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.n):</span><br><span class="line">            y = (self.state[i] &amp; self.highbit) + (self.state[(i + <span class="number">1</span>) % (self.n)] &amp; self.lowbit)</span><br><span class="line">            self.state[i] = (y&gt;&gt;<span class="number">1</span>) ^ self.state[(i + self.o) % (self.n)]</span><br><span class="line">            <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                self.state[i] = self.state[i] ^ self.mask</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Next</span>(<span class="params">self</span>):</span><br><span class="line">        tmp=self.state[self.flag]</span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; self.b</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; self.c</span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">18</span>)</span><br><span class="line">        self.flag+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.flag==self.n:</span><br><span class="line">            self.twist()</span><br><span class="line">            self.flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getrandomint</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.Next()</span><br></pre></td></tr></table></figure>

<p> <del>很好，现在你已经获得了 $python$ 中 $random$ 库的秘密了</del></p>
<h3 id="破解算法"><a href="#破解算法" class="headerlink" title="破解算法"></a>破解算法</h3><h4 id="破解状态"><a href="#破解状态" class="headerlink" title="破解状态"></a><strong>破解状态</strong></h4><p>由输出的随机数破解当前状态其实就是求解 $Next$ 的逆函数。那么我们来看， $Next$ 函数的基本形式是$tmp&#x3D;tmp\bigoplus(tmp &gt;&gt; x)\bigwedge y$，如果我们把 $tmp$ 看成是它的二进制数向量，那么容易得到， $tmp&gt;&gt;x$ 实际上就是 $tmp$ 右乘矩阵 $X$<br>$$<br>X&#x3D;\left[<br> \begin{matrix}<br>   0 &amp; \cdots &amp; 0 &amp; 1 &amp; \cdots &amp; 0\\<br>   \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   0 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots &amp; 1\\<br>   \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   0 &amp; \dots &amp; 0 &amp; 0 &amp; \dots &amp; 0\\<br>  \end{matrix}<br>  \right]\\<br>$$<br>同样地，对于左移(&lt;&lt;)，我们可以构造 $X^{‘}$<br>$$<br>X^{‘}&#x3D;\left[<br> \begin{matrix}<br>   0 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\<br>   \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   1 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\<br>   \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   0 &amp; \dots &amp; 1 &amp; 0 &amp; \dots &amp; 0\\<br>  \end{matrix}<br>  \right]\\<br>$$<br>再进一步， $tmp\bigoplus(tmp &gt;&gt; x)$ 就是 $tmp\times(I+X)$ 。另一方面，运算 $a\ \bigwedge\ b$ 相当于 $a\times(b\times I)$ ，因此，整一步操作相当于 $tmp$ 右乘一个矩阵 $L&#x3D;(I+X)\times(b\times I )$ ，整个 $Next$ 函数相当于执行了这样一个操作3次，可以理解为 $tmp$ 右乘一个更大的矩阵 $F$ 。那么我们能够从输出的随机数逆推得到 $state$ 的充要条件就是 $F$ 可逆。事实上，这是成立的。</p>
<p>最后，我们需要注意我们得到的随机数在输出时是否进行了旋转。换句话说，我们得到的 $n$ 个连续输出未必就是一组 $state$ 产生的，但是如果我们希望通过 $n$ 个连续输出得到 $seed$ ，那么它们必须是由同一组 $state$ 输出的。</p>
<p>下面是恢复 $state$ 的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="comment">#state的比特数</span></span><br><span class="line">d=</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">b=</span><br><span class="line">c=</span><br><span class="line"><span class="comment">#n个随机数比特向量构成的列表</span></span><br><span class="line">x=[]</span><br><span class="line"><span class="comment">#获得d*d的单位矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_I</span>(<span class="params">d</span>):</span><br><span class="line">    I=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        temp=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d)]</span><br><span class="line">        temp[i]=<span class="number">1</span></span><br><span class="line">        I.append(temp)</span><br><span class="line">    <span class="keyword">return</span> matrix(GF(<span class="number">2</span>),I)</span><br><span class="line"><span class="comment">#获得&gt;&gt;l的变换矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_right</span>(<span class="params">l</span>):</span><br><span class="line">    temp=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">        temp.append([<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d)])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d-l):</span><br><span class="line">        k=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d)]</span><br><span class="line">        k[i]=<span class="number">1</span></span><br><span class="line">        temp.append(k)</span><br><span class="line">    <span class="keyword">return</span> matrix(GF(<span class="number">2</span>),temp).transpose()</span><br><span class="line"><span class="comment">#获得&lt;&lt;l的变换矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_left</span>(<span class="params">l</span>):</span><br><span class="line">    temp=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">        temp.append([<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d)])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d-l):</span><br><span class="line">        k=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d)]</span><br><span class="line">        k[i]=<span class="number">1</span></span><br><span class="line">        temp.append(k)</span><br><span class="line">    <span class="keyword">return</span> matrix(GF(<span class="number">2</span>),temp)</span><br><span class="line"><span class="comment">#获得&amp;的变换矩阵,前文中的（b*I)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_and</span>(<span class="params">a</span>):</span><br><span class="line">    a=<span class="built_in">bin</span>(a)[<span class="number">2</span>:].zfill(d)</span><br><span class="line">    m=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        k=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(d)]</span><br><span class="line">        k[i]=<span class="built_in">int</span>(a[i])</span><br><span class="line">        m.append(k)</span><br><span class="line">    <span class="keyword">return</span> matrix(GF(<span class="number">2</span>),m)</span><br><span class="line"><span class="comment">#生成变换矩阵</span></span><br><span class="line">U=get_right(<span class="number">11</span>)</span><br><span class="line">S=get_left(<span class="number">7</span>)</span><br><span class="line">T=get_left(<span class="number">15</span>)</span><br><span class="line">L=get_right(<span class="number">18</span>)</span><br><span class="line">B=get_and(b)</span><br><span class="line">C=get_and(c)</span><br><span class="line">I=get_I(d)</span><br><span class="line">F=(I+U)*(I+S*B)*(I+T*C)*(I+L)</span><br><span class="line">state=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    X=matrix(GF(<span class="number">2</span>),x[i])</span><br><span class="line">    O=F.solve_left(X)</span><br><span class="line">    o=<span class="string">&#x27;0b&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line">        o+=<span class="built_in">str</span>(O[<span class="number">0</span>][k])</span><br><span class="line">    state.append(<span class="built_in">int</span>(o,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h4 id="恢复seed"><a href="#恢复seed" class="headerlink" title="恢复seed"></a>恢复seed</h4><p>恢复 $seed$ 相当于恢复初始 $state$ ，那么我们需要求解 $twist$ 的逆函数。前文已经提到过，由 $state$ 生成 $state^{\ast}$ 的公式为<br>$$<br>state_i^{\ast}&#x3D;(y\bigoplus state_{i+o)}\times A\ \ 上标\ast表示这是覆盖以后的值<br>$$<br>矩阵 $A$ 是可逆的，于是我们求出 $(y\bigoplus state_{i+o})$ ，现在如果我们已知 $state_{i+o}$ ，那么 $y$ 就是可以知道的，也就是 $state_i$ 的最高位和 $state_{i+1}$ 的低位。此时只需要相邻两个 $state^{\ast}$ 我们就可以推知完整的一个 $state$ 。</p>
<p>那么问题来了，$state_{i+o}$ 在执行完 $twist$ 函数后被覆盖，原来的 $state_{i+o}$ 也是需要我们复原的，而我们复原又需要用到它，这就陷入循环了。事实果真如此吗？</p>
<p>我们来看，计算 $state^{\ast}<em>{n-1}$ 时，前面所有的 $state$ 已经被新的所覆盖，此时执行 $twist$ 函数所用到的 $state</em>{i+o}$ 其实是覆盖后的结果 $state^{\ast}_{i+o}$ ，而这个值是在我们由输出结果计算 当前$state$ 序列时已经得到了，可以直接加入运算。</p>
<p>也就是说，存在一部分的 $state$ ，它们执行 $twist$ 函数时用到的  $state_{(i+o)}$ 是被覆盖后的值，对于这些 $state$ 我们是可以利用上面的方法复原的，而后我们再利用这些复原值来反推剩下的。一言以蔽之，整个复原过程要从最后一个 $state$ 开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line">n=<span class="number">233</span></span><br><span class="line">o=<span class="number">130</span></span><br><span class="line">mask=<span class="number">0x9908f23f</span></span><br><span class="line"><span class="comment">#标准的初始化序列</span></span><br><span class="line">standard=[]</span><br><span class="line"><span class="comment">#旋转一次以后的序列</span></span><br><span class="line">state=[]</span><br><span class="line"><span class="comment">#获得A矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_A</span>(<span class="params">mask</span>):</span><br><span class="line">    mask=<span class="built_in">bin</span>(mask)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">    M=[<span class="built_in">int</span>(mask[_]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mask))]</span><br><span class="line">    A=[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)] <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">        A[i][i+<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">    A.append(M)</span><br><span class="line">    <span class="keyword">return</span> matrix(GF(<span class="number">2</span>),A)</span><br><span class="line">A=get_A(mask)</span><br><span class="line"><span class="comment">#把state转化成二进制向量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_state</span>(<span class="params">state</span>):</span><br><span class="line">    new_state=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> state:</span><br><span class="line">        tmp=<span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">        new_state.append([<span class="built_in">int</span>(tmp[_]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp))])</span><br><span class="line">    <span class="keyword">return</span> new_state</span><br><span class="line">state=bin_state(state)</span><br><span class="line"><span class="comment">#主要部分</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="comment">#求state_i的高位</span></span><br><span class="line">    tmp=matrix(GF(<span class="number">2</span>),state[i])+matrix(GF(<span class="number">2</span>),state[(i+o)%n])</span><br><span class="line">    tmp=tmp*A.inverse()</span><br><span class="line">    s=[]</span><br><span class="line">    s.append(tmp[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#求state__i的低位</span></span><br><span class="line">    tmp=matrix(GF(<span class="number">2</span>),state[i-<span class="number">1</span>])+matrix(GF(<span class="number">2</span>),state[(i-<span class="number">1</span>+o)%n])</span><br><span class="line">    tmp=tmp*A.inverse()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">        s.append(tmp[<span class="number">0</span>][j+<span class="number">1</span>])</span><br><span class="line">    state[i]=s </span><br><span class="line"><span class="comment">#以十进制数的形式输出state</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_state</span>(<span class="params">state</span>):</span><br><span class="line">    new_state=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> state:</span><br><span class="line">        tmp=<span class="string">&#x27;0b&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            tmp+=<span class="built_in">str</span>(j)</span><br><span class="line">        new_state.append((<span class="built_in">int</span>(tmp,<span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> new_state</span><br><span class="line"><span class="built_in">print</span>(dec_state(state))</span><br><span class="line"><span class="built_in">print</span>(standard)</span><br></pre></td></tr></table></figure>

<p>对比我们的计算结果和标准答案，发现只有第一个（ $seed$ ）是不一样的。这就很有趣，后面所有数都一样唯独第一个不同，说明我们的算法没什么太大的问题，而且，根据这两个序列所生成的新序列以及之后的所有序列都是一样的（可以自己试一下）。也即是说，我们现在已经可以预测后面的结果，但是不能复原之前的随机数。</p>
<p>那么接下来我们看到由 $seed$ 生成第一序列的函数。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state[i] = a * (state[i-<span class="number">1</span>] ^ (state[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>)) + i</span><br><span class="line">state[i] &amp;= <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure>

<p>这是一个模运算。$\bigwedge\  0xffffffff$ 实际上就是取后32位，即取模 $2^{32}$ 的余数。然后我们已知 $state[1]$ ，要求 $state[0]$ ，带入上式<br>$$<br>(state[0] \bigoplus (state[0] &gt;&gt; 30))&#x3D;state[1]*a^{-1}\ mod\ 2^{32}<br>$$<br>而 $(state[0] \bigoplus (state[0] &gt;&gt; 30))$ 我们之前讨论过是 $state[0]\times L$ 的形式，矩阵 $L$ 也是容易求的，因此恢复 $seed$ 只需要在之前的基础上再进一步即可。</p>
<p>由此我们还得到了一种攻击方法，如果我们已知初时序列中某个 $state_i$ 的值和 $i$ 的值，那么我们可以推算出整个初始序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line">d=<span class="number">32</span></span><br><span class="line">a=</span><br><span class="line">state=[]</span><br><span class="line">a=a.inverse_mod(<span class="number">2</span>**<span class="number">32</span>)</span><br><span class="line">state[<span class="number">0</span>]=(state[<span class="number">1</span>]*a)%(<span class="number">2</span>**<span class="number">32</span>)</span><br><span class="line">state[<span class="number">0</span>]=bin_state(state[<span class="number">0</span>])</span><br><span class="line">I=get_I(d)</span><br><span class="line">R=get_right(<span class="number">30</span>)</span><br><span class="line">L=(I+R)</span><br><span class="line">s=matrix(GF(<span class="number">2</span>),state[<span class="number">0</span>])</span><br><span class="line">s=s*L.inverse()</span><br><span class="line">tmp=<span class="string">&#x27;0b&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">0</span>]:</span><br><span class="line">    tmp+=<span class="built_in">str</span>(i)</span><br><span class="line">state[<span class="number">0</span>]=<span class="built_in">int</span>(tmp,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(state)</span><br><span class="line"><span class="built_in">print</span>(standard)</span><br></pre></td></tr></table></figure>

<p>对比发现二者一致。说明我们已经完全复原了 $MT19937$ 。</p>
<h3 id="有空放几个例题吧，累了"><a href="#有空放几个例题吧，累了" class="headerlink" title="有空放几个例题吧，累了"></a>有空放几个例题吧，累了</h3>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Cata1ysts
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/09/15/MT19937%E7%AC%94%E8%AE%B0/" title="MT19937笔记">http://example.com/2022/09/15/MT19937笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PRNG/" rel="tag"># PRNG</a>
              <a href="/tags/Mersenne-twister/" rel="tag"># Mersenne twister</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/05/%E6%A8%A1n%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%E7%AE%97%E6%B3%95/" rel="prev" title="模n的平方根算法">
      <i class="fa fa-chevron-left"></i> 模n的平方根算法
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mersenne-twister-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">Mersenne twister 算法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90"><span class="nav-number">1.2.</span> <span class="nav-text">初始序列生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">旋转算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">输出算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.</span> <span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">破解算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E8%A7%A3%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">破解状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8Dseed"><span class="nav-number">2.2.</span> <span class="nav-text">恢复seed</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%A9%BA%E6%94%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E9%A2%98%E5%90%A7%EF%BC%8C%E7%B4%AF%E4%BA%86"><span class="nav-number">3.</span> <span class="nav-text">有空放几个例题吧，累了</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cata1ysts"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Cata1ysts</p>
  <div class="site-description" itemprop="description">努力学习crypto并希望有一个web大手子浇浇的pwn萌新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cata1ysts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":250},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
